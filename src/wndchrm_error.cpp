#include <errno.h>
#include <iostream>
#include <sstream>
#include <stdarg.h>
#include <stdio.h>
#include <string.h>
#include <stdlib.h>





#include "wndchrm_error.h"

#define MAX_ERROR_MESSAGE 1024


std::ostringstream error_messages;

/* global variable */
// Verbosity levels:
// 		0-Classification accuracy and similarity and confusion matrices only
// 		1-Individual
// 		2-Everything except the confusion and similarity matrices when printing to std out only
// 		>2-Everything
int verbosity = 2;

// appends the system error message for the current errno
void catErrno () {
	char error_buffer[MAX_ERROR_MESSAGE];
	size_t found;
	char newline=0;

	if (errno != 0) {
	// Append any system error string
#ifdef _GNU_SOURCE
		strncpy (error_buffer, strerror_r(errno, error_buffer, MAX_ERROR_MESSAGE), MAX_ERROR_MESSAGE);
#else
		strerror_r(errno, error_buffer, MAX_ERROR_MESSAGE);
#endif

		if (strlen(error_buffer)) {
			// clean trailing newlines
			found = error_messages.str().find_last_not_of("\n\r");
			if (found != std::string::npos) {
				if ( error_messages.str().find_first_of("\n\r",found) != std::string::npos ) newline = 1;
				error_messages.seekp(found+1);
			}
			error_messages << ": " << error_buffer;
			if (newline) error_messages << "\n";
		}

		errno = 0;
	}
}
/*
   Accumulates errors and warnings to be shown later
   N.B.: Variadic - use like printf
*/
void catError (const char *fmt, ...) {
	va_list ap;
	size_t err_lngth;
	char error_buffer[MAX_ERROR_MESSAGE];

	// process the printf-style parameters
	va_start (ap, fmt);
	err_lngth = vsnprintf (error_buffer,MAX_ERROR_MESSAGE, fmt, ap);
	va_end (ap);

	error_messages << error_buffer;

	catErrno();
}

void catError (const std::string &error) {
	error_messages << error;
}


/*
   displays an error message and optionally stops the program
   If stopping, shows the accumulated error_message generated by catError()
   N.B.: variadic.  First parameter is the stop flag, followed by parameters same as printf
*/
int showError(int stop, const char *fmt, ...) {
va_list ap;
size_t err_lngth;
char error_buffer[MAX_ERROR_MESSAGE];
size_t found;

// add the printf-style parameters to error_message
	if (fmt && *fmt) {
		va_start (ap, fmt);
		err_lngth = vsnprintf (error_buffer,MAX_ERROR_MESSAGE, fmt, ap);
		va_end (ap);
		if (err_lngth) error_messages << error_buffer;
	}


// Append any system error string
	if (errno != 0 && error_messages.str().size()) {
		catErrno();
	}

	if (error_messages.str().size()) {
		std::cerr << error_messages.str();
	// Make sure we print a newline
		found = error_messages.str().find_last_not_of("\n\r");
		if ( error_messages.str().find_first_of("\n\r",found) == std::string::npos ) std::cerr << "\n";
	}

	if (stop && !error_messages.str().size()) {
		std::cerr << "Fatal error - terminating.\n";
	} else if (stop) {
		exit(0);
	}

	return(0);
}


const char* translateError( WNDCHRM_ERROR return_val )
{
	switch( return_val )
	{
		case WC_UNINITIALIZED:
			return "return value is unused.";
		case WC_NO_ERROR:
			return "";
		case WC_IPP_NULL:
			return "intermediate pixel_plane saved in MatrixMap is null.";
		case WC_MM_FAIL_RECURSIVE_CALL:
			return "call to MatrixMap::obtain_transform() failed in recursion.";
		case WC_TRANSFORM_FAIL:
			return "transform algorithm failed to produce an output pixel plane";
		case WC_EMPTY:
			return "nothing in container.";
		//case WC_TRANSFORM_NOT_IN_PHONEBOOK:
		//	return "transform requested was not registered at compile time.";
		case WC_NOT_IMPLEMENTED:
			return "requested functionality not implemented.";
		case WC_INPUT_IMAGEMATRIX_NULL:
			return "pixelplane passed to transform was corrupted.";
	}
	return "";
}



const std::string getErrorString () {
	return (error_messages.str());

}
